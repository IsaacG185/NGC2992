define pulseperiod_magic() {
%!%+
%\function{pulseperiod_magic}
%\synopsis{UNDER HEAVY DEVELOPMENT; USAGE ON YOUR OWN RISK}
%\usage{Struct_Type pulseperiod_magic(Struct_Type[] lc, Double_Type p0, dpmax);}
%\qualifiers{
%    \qualifier{ccflim}{cross-correlation threshold (default: .7)}
%}
%\description
%    UNDER DEVELOPMENT, USE WITH CAUTION! Send questions or bugs to
%    matthias.kuehnel@sternwarte.uni-erlangen.de
%    see pulseperiod_epfold
%
%    lc[] = struct { time, rate, error, fracexp }
%    with time in MJD
%
%    p0 = pulse period in seconds
%    dpmax = maximum allowed period derivative
%    
%    returns struct {
%      time (mean in MJD)
%      period (in s)
%      error (in s)
%    }    
%\seealso{pulseperiod_epfold, pulseperiod_phase_connect, bayesian_blocks}
%!%-
  variable lc, p0, dpmax;
  switch (_NARGS)
    { case 3: (lc, p0, dpmax) = (); }
    { help(_function_name); return; }

  % epoch folding of all light curves
  % - sanity checks done
  % - also splits at gaps if needed
  % - determines light curve/segment properties (lcp)
  variable lcp;
  variable epfres = pulseperiod_epfold(
    lc, p0;; struct_combine(__qualifiers, struct { getlcp = &lcp })
  );
  lc = epfres.lc;
  variable nlc = length(lc);
  p0 /= 86400; % s -> d

  % qualifiers
  variable nbins = qualifier("nbins", 32);
  variable clim = qualifier("ccflim", .7);

  % prepare output structure
  variable out = struct {
    time = lcp.time[[:-2]], period, error,
    epfold = epfres, % epoch folding result
    pblock, % periods from bayesian blocks
    phasecon % all possible periods from phase connection
  };
  
  % times of constant period using bayesian_blocks
  % periods are in seconds here (as returned by pulseperiod_epfold)
  variable n = where(epfres.period > 0);
  variable pblock = get_blocks_data(bayesian_blocks(struct {
    tt = epfres.time[n],
    cell_data = { epfres.period[n], epfres.error[n] }
  }));
  out.pblock = struct {
    time_lo = pblock.time, time_hi = pblock.time + pblock.dt,
    period = pblock.data, error = pblock.error
  };

  % first iteration period evolution structure
  variable final = struct {
    time = @(lcp.time),
    period = Array_Type[nlc], % arrays as the determined phase shift below
    error = Array_Type[nlc],  % is degenerated by integers
    block = Integer_Type[nlc] % block index
  };
  variable i;
  _for i (0, nlc-1, 1) {
    % use period of the corresponding (bayesian) block
    n = wherefirst(pblock.time <= final.time[i] <= pblock.time+pblock.dt);
    if (n == NULL) {
      vmessage("warning(%s): light curve [%d] outside of the period blocks; assuming nearest period", _function_name, i);
      n = where_min(abs(pblock.time + .5*pblock.dt - final.time[i]))[0];
    }
    final.block[i]  = n;
    final.period[i] = [pblock.data[n]/86400];  % back into days
    final.error[i]  = [pblock.error[n]/86400];
  }
  % cross-correlation
  vmessage("cross correlating");
  % error propagate the period uncertainties into a phase shift
  variable dphi = Double_Type[nlc-1];
  _for i (0, nlc-2, 1) {
    dphi[i] = (final.time[i+1] - final.time[i])
            * (1./(final.period[i][0] - final.error[i][0]) - 1./final.period[i][0]);
  }
%  % loop over all blocks
%  _for i (0, length(pblock.data)-1, 1) {
    % sanity check for min(dphi) < 1 (as we cannot measure the integer part)
    variable start = where_min(dphi)[0];
    if (dphi[start] > 1) {
      % use a qualifier here to continue? i.e. providing a specific period?
      vmessage("error(%s): times between light curves are too large,", _function_name);
      vmessage("resulting in pulse phase uncertainties of > 1, can't cross-correlate!");
      return;
    }
    % sort by distance to start and loop
    variable j;
    foreach j (array_sort(abs(final.time[[:-2]] - final.time[start]))) {
      % left (-1), right side (+1), or at (0) the starting point?
      variable s = sign(final.time[j] - final.time[start]);
      % create pulse profile of current light curve and its right neighbor
      % using a commond reference time and period
      variable k = [j+1, j, j-1][s+1]; % index of period to use
      % we have to use every period estimate
      variable l;
      variable pnew = Double_Type[0], perr = @pnew;  %, pdot = @pnew;
      _for l (0, length(final.period[k])-1, 1) {
	% vmessage("%f %f %f", final.period[k][l], mean(lc[j].time), final.time[j+1]);
        variable ref = pfold(
          lc[j].time, lc[j].rate, final.period[k][l], lc[j].error;
          nbins = nbins, dt = lcp.dt[j]*lc[j].fracexp, exact, t0 = final.time[j]
        );
        variable nei = pfold(
          lc[j+1].time, lc[j+1].rate, final.period[k][l], lc[j+1].error;
          nbins = nbins, dt = lcp.dt[j+1]*lc[j+1].fracexp, exact, t0 = final.time[j]
	);
	% hplot(ref);()=keyinput(;nchrs=1);
	% hplot(nei);()=keyinput(;nchrs=1);	
        % error propagate phase shift again
        dphi[j] = (final.time[j+1] - final.time[j])
                * (1./(final.period[k][l] - final.error[k][l]) - 1./final.period[k][l]);
        % determine phase shift
        variable phi, ccf;
        (phi,ccf) = pulseprofile_phase_connect(nei,ref);
	if (ccf < clim) {
	  vmessage("warning(%s): skipping [%d] (ccf = %.2f)", _function_name, j, ccf); continue;
	}
        % shift if measured shift is larger than expected (only applies if dphi < 1)
        if (abs(phi) > dphi[j]) {
	  phi = phi - [0, sign(phi)];
	  % select the least worse difference
	  phi = phi[where_min(abs(phi))];
	}
        % add integers within expected phase shift range
        phi += [-int(floor(dphi[j])):int(floor(dphi[j]))];
        % calculate new period assuming dot{P} = 0
	variable padd = 1./(phi/(final.time[j+1] - final.time[j]) + 1./final.period[k][l]);
        pnew = [pnew, padd];
        perr = [perr, padd*lcp.dt[j]/(final.time[j+1] - final.time[j])];
      }
      if (length(pnew) == 0) { continue; }
      final.period[j] = pnew;
      final.error[j] = perr;
    }

    % remove last entry from final evolution (we lost one degree of freedom)
    struct_filter(final, [:-2]);
    % copy into output
    out.phasecon = COPY(final);
    % now we have multiple possible period evolutions,
    % first build a list of all possible indice combinations
    variable ind  = list_new;
    list_append(ind, ones(length(final.period))-1); % start with first period indices
    while (not all(ind[-1] == array_map(Integer_Type, &length, final.period)-1)) {
%    while (ind[-1][-1] != length(final.period[-1])-1) {
      % increment
      variable nind = @(ind[-1]);
      j = 0;
      forever {
	nind[j]++;
        if (nind[j] == length(final.period[j])) { nind[j] = 0; j++; }
	else { break; }
      }
      list_append(ind, nind);
    }
    vmessage("checking %d possible solutions", length(ind));
    % check each solution against pdot constraints
    n = Integer_Type[length(ind)];
    variable stat = Double_Type[length(ind)] + _Inf;
    _for j (0, length(ind)-1, 1) {
      pnew = Double_Type[length(final.period)]; perr = @pnew;
      _for k (0, length(pnew)-1, 1) {
	pnew[k] = final.period[k][ind[j][k]];
	perr[k] = final.error[k][ind[j][k]];
      }
      % use a linear regression to estimate pdot
      variable lin = linear_regression(final.time, pnew, perr);
      if (abs(lin.b > dpmax)) { continue; }
      stat[j] = lin.chisq;
      n[j] = 1;
    }
    n = where(n == 1);
    vmessage("  %d left after pdot-constraint", length(n));
    % select set of indices corresponding to best statistic
    n = n[where_min(stat[n])[0]];
    _for k (0, length(pnew)-1, 1) {
      pnew[k] = final.period[k][ind[n][k]];
      perr[k] = final.error[k][ind[n][k]];
    }
    vmessage("  selecting most likelihood solution (chi^2_red = %.2f)", stat[n]);
    % return best solution
    final.period = pnew*86400;
    final.error = perr*86400;
%  }
  out.period = final.period;
  out.error  = final.error;
  
  return out;
}
