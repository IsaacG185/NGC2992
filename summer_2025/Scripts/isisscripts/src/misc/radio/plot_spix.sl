require( "xfig" );
require( "png" ); 

%%%%%%%%%%%%%%%%
define plot_spix()
%%%%%%%%%%%%%%%%
%!%+
%\function{plot_spix}
%\synopsis{plots a spectral index map using the struct provided by make_spix}
%\usage{plot_spix(Struct_Type values, String_Type outputname);}
%\qualifiers{
%\qualifier{inv_color}{[=0] inverts color scale (i.e., roles of red and blue switch)}
%\qualifier{min_spix}{[=min(values.spec_map)] minimum spectral index to be plotted}
%\qualifier{max_spix}{[=max(values.spec_map)] maximum spectral index to be plotted}
%\qualifier{lum_scale}{[=1] use the sum of the intensity of both images to scale
%                      the brightness of the spectral index map, set to 0 in order to
%                      show the significant regions at uniform brightness}
%\qualifier{nsigma [=0]}{spectral index values are only shown for pixels where
%                      the emission (in both bands) is above the specified
%                      significance (e.g., nsigma=3 means that the emission
%                      has to be 3*sigma above the noise level)}
%\qualifier{nsigma_lo}{[=0] emission limit for low frequency  band separately}
%\qualifier{nsigma_hi}{[=0] emission limit for high frequency band separately}
%\qualifier{low_lum_limit}{[=0] number of stdevs above the median that luminosity data
%                                        begins to be displayed}
%\qualifier{hi_lum_limit}{[=0] number of (e^n) stdevs above the median at which color
%                                        is fully saturated (0 -> no limit)}
%\qualifier{ra_frac}{[={0.0,1.0}] fraction of RA to display with {left,right} limits,
%                                        will keep scaling}
%\qualifier{dec_frac}{[={0.0,1.0}] fraction of DEC to display with {left,right} limits,
%                                        will keep scaling}
%\qualifier{ra_mas}{[={NULL,NULL}] {left,right} limits of image in mas}
%\qualifier{dec_mas}{[={NULL,NULL}] {top,bottom} limits of image in mas}
%\qualifier{size}{[=14] size of plot (maximum dimension)}
%\qualifier{print_mode}{[=0] set =1 for white background}
%\qualifier{blue_bkgr}{[=0] for a dark blue background set to 1}
%\qualifier{quadratic}{create a quadratic image, by default the scaling is such that
%                                        scaling in RA and DEC is equal}
%\qualifier{no_labels}{plot no labels}
%\qualifier{pmodecolor}{[=1] color saturation decreases wth this root of luminosity
%                                        (i.e., 2=sqrt) in print mode only}
%\qualifier{beam_color}{[="gray"] beam color}
%\qualifier{src_name}{[=values.source] manually set source name in plot}
%\qualifier{obs_date}{[=values.date] manually set date in plot}
%\qualifier{xyunit}{[="mas"] unit of the x/y labels, can be changed between "mas", "arcsec", "arcmin" and "deg";
%                                               assumption: FITS header sets unit "mas"}                                       
%\qualifier{xfig_tmp_dir}{[=xfig_get_tmp_dir] set the path for the tmp directory used by xfig}
%\qualifier{xfig_autoeps_dir}{[=xfig_get_autoeps_dir] set the path for the autoeps directory}
%\qualifier{color_scheme}{[="hot"] setting another colorscheme (lum_scale=0 is automatically set)}
%\qualifier{h_scalebar}{if given, a horizontal scalebar is plotted above the spixmap}
%\qualifier{no_scalebar}{if given, no scalebar is plotted}
%}
%\description
%    This function creates a spectral image plot with xfig from the
%    structure generated by make_spix. The log of the average brightness
%    is displayed as color saturation and the spectral index as hue so
%    that both spectral index and brightness are apparent in the image.
%    It will ouput a .pdf file of the plot with a color scale bar on the
%    side.  For the luminosity scaling, the data below the median value
%    is cut out and the data above the median is fit to a gaussian. The
%    hi_lum_limit and low_lum_limit are based on the stdev from this fit.
%\seealso{make_spix, read_spix, write_spix}
%!%-
{  
  variable values,outname;
  switch(_NARGS)
  { case 2: (values,outname) = (); }
  { help(_function_name()); return; }
  
  %% moving input data into local variables so it's not modified
  variable avg_lum  = @values.avg_lum;
  variable spec_map = @values.spec_map;
  variable mlo      = @values.lo_map;
  variable mhi      = @values.hi_map_shifted;
  variable length_x = length(mlo[*,0]);
  variable length_y = length(mlo[0,*]);

  variable low_lum_limit = qualifier("low_lum_limit", 0); % sets the number of standard deviations above the median that luminosity data begins to be displayed
  variable hi_lum_limit  = qualifier("hi_lum_limit", 0);  % sets the number of (e^n) standard deviations at which color is fully saturated (default 0 -> no limit)
  variable lum_scale     = qualifier("lum_scale", 1);     % set to 0 to turn off brightness scaling
  variable inv_color     = qualifier("inv_color",0);      % if set to 1 blue -> optically thin (low spectral index)
  variable image_size    = qualifier("size", 14.);        % size of resulting image (maximum dimension)
  variable print_mode    = qualifier("print_mode", 0);    % makes white background if = 1;
  variable pmodecolor    = qualifier("pmodecolor", 1);    % causes color saturation to decrease with this root of luminosity (i.e. 2=sqrt) in print mode only
  variable src_name      = qualifier("src_name", values.source);
  variable obs_date      = qualifier("obs_date", values.date);
  variable dec_frac      = qualifier("dec_frac",[0.,1.]);
  variable ra_frac       = qualifier("ra_frac",[0.,1.]);
  variable color_scheme  = qualifier("color_scheme","hot");
  variable nsigma        = qualifier("nsigma", 0 );        % if set, only spix values, where the emission (in both bands) is above the specified number of sigma, are shown
  variable nsigma_lo     = qualifier("nsigma_lo", nsigma); % emission in low  freq band has to above the specified number of sigma       
  variable nsigma_hi     = qualifier("nsigma_hi", nsigma); % emission in high freq band has to above the specified number of sigma       
  variable no_labels	= qualifier("no_labels");
  variable xyunit       = qualifier("xyunit","mas");
  % if you want to have a dark blue background:
  variable bluebkgr = qualifier("blue_bkgr", 0);
    
  %% fitting noise in avg_lum if parameters are used later
  %% assumes median value is in noise. Fits a gaussian to the (hopefully) noise
  if(lum_scale){ %low_lum_limit!=0 or hi_lum_limit!=0){
    variable sigma_lum, med_lum;
    (med_lum , sigma_lum) = fit_gauss_to_img_noise (avg_lum);
  }
  %% fitting noise of the low  frequency map if parameters are used later
  if(nsigma_lo != 0){
    variable sigma_lo, med_lo;
    ( med_lo , sigma_lo) = fit_gauss_to_img_noise (mlo);
  }
  %% fitting noise of the high frequency map if parameters are used later
  if(nsigma_hi != 0){
    variable sigma_hi, med_hi;
    ( med_hi , sigma_hi) = fit_gauss_to_img_noise (mhi);
  }

  %% displaying average luminosity as color saturation
  %% in the next steps the values for avg_lum are set
  if(lum_scale){
    avg_lum = _max( avg_lum , med_lum + low_lum_limit * sigma_lum );
    if(hi_lum_limit > 0){
      hi_lum_limit = exp(hi_lum_limit);
      avg_lum = _min ( avg_lum , med_lum + hi_lum_limit * sigma_lum );
    }
    avg_lum = log( _max(avg_lum, min(avg_lum[where(avg_lum>0)]) ) );
    avg_lum -= min(avg_lum);
    if(print_mode) avg_lum = avg_lum^pmodecolor;
    avg_lum /= max(avg_lum)*2;
  }
  else {
    avg_lum[*,*] = 0.5; % all values have the full color
  }
  variable bkgr = (print_mode ? 1 : 0); % saturation for unvalied spix pixels, 1 = white background, 0 = black background
  if(nsigma_lo != 0) avg_lum[where(mlo < med_lo + sigma_lo * nsigma_lo)] = bkgr;
  if(nsigma_hi != 0) avg_lum[where(mhi < med_hi + sigma_hi * nsigma_hi)] = bkgr;
  if(print_mode){    avg_lum = 1-avg_lum;  }


  %%%%%%%%%%%%%%%%%%%%% GENERATING PLOTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%
  
  %setting plot boundaries
  variable dec_len       = length(spec_map[*,0])-1;
  variable ra_len        = length(spec_map[0,*])-1;
  variable ra_px_center  = @values.ra_px_center;
  variable ra_steps      = @values.ra_steps;
  variable dec_px_center = @values.dec_px_center;
  variable dec_steps     = @values.dec_steps;    
  variable ra_min        = -(ra_px_center-0.5)*ra_steps;
  variable ra_max        = (ra_px_center-0.5)*ra_steps;
  variable dec_min       = -(dec_px_center-0.5)*dec_steps;
  variable dec_max       = (dec_px_center-0.5)*dec_steps;
  
  variable unit_fac,unit_lab_x,unit_lab_y;
  switch (xyunit)
  { case "mas" : unit_fac=1.; }
  { case "arcsec" : unit_fac=1./1e3; }
  { case "arcmin" : unit_fac=1./1e3/60; }
  { case "deg" : unit_fac=1./1e3/3600; }
  unit_lab_x=sprintf("Relative RA [%s]",xyunit);
  unit_lab_y=sprintf("Relative DEC [%s]",xyunit);
  
  % correct ra/dec steps and beam smaj/smin for given unit
  ra_steps *= unit_fac;
  dec_steps *= unit_fac;
  
  
  %% cutting image
  variable indxdec, indxra;
  if (qualifier_exists("ra_mas") or qualifier_exists("dec_mas"))
  {
    variable ra_mas = qualifier("ra_mas", {ra_min,ra_max});
    if (ra_mas[0] < ra_mas[1])  ra_mas = { ra_mas[1], ra_mas[0] };
    ra_mas  = { _min( ra_mas[0], ra_min) , _max( ra_mas[1], ra_max) };
    variable dec_mas = qualifier("dec_mas", {dec_min,dec_max});
    if (dec_mas[0] > dec_mas[1])  dec_mas = { dec_mas[1], dec_mas[0] };
    dec_mas = { _max(dec_mas[0],dec_min) , _min(dec_mas[1],dec_max) };
    indxdec = [int(_max(dec_mas[0]/dec_steps + (dec_px_center-0.5) , 0)) :
	       int(_min(dec_mas[1]/dec_steps + (dec_px_center-0.5) , dec_len))];
    indxra  = [int(_max( ra_mas[0]/ ra_steps + ( ra_px_center-0.5) , 0)) :
	       int(_min( ra_mas[1]/ ra_steps + ( ra_px_center-0.5) , ra_len))];
    ra_px_center  -= int( ra_mas[0]/ra_steps  + (ra_px_center-0.5) );
    dec_px_center -= int(dec_mas[0]/dec_steps + (dec_px_center-0.5) );
    ra_min  =  ra_mas[0];  ra_max = ra_mas[1];
    dec_min = dec_mas[0]; dec_max = dec_mas[1];
  }
  else
  {
    indxdec = [int(dec_len*dec_frac[0]) : int(dec_len*dec_frac[1])];
    indxra  = [int( ra_len* ra_frac[0]) : int( ra_len* ra_frac[1])];
  }
  spec_map = spec_map[ indxdec , indxra ];
  avg_lum  = avg_lum [ indxdec , indxra ];
  mlo      = mlo     [ indxdec , indxra ];
  mhi      = mhi     [ indxdec , indxra ];
  
  %% setting scale
  variable width  = abs(ra_min  - ra_max);
  variable height = abs(dec_min - dec_max);
  if (qualifier_exists("quadratic")){width = 1; height = 1;} % create quadratic image
  variable image_scale = _max(width, height);
  width  *= image_size/image_scale;
  height *= image_size/image_scale;
  variable pl = xfig_plot_new(width,height);
  variable beam_dec_scale = image_size/(image_scale*abs(dec_max-dec_min));  %for scaling the beam later
  variable beam_ra_scale  = image_size/(image_scale*abs(ra_max-ra_min));    %for scaling the beam later
  
  xfig_new_color("grey",0x616161);
  variable color = (print_mode ? "black" : "grey");
  pl.world(ra_min,ra_max,dec_min,dec_max; color=color);
  pl.axis(; color =color, ticlabels2=0);
  ifnot (qualifier_exists("no_labels")){
  pl.xlabel(unit_lab_x);
  pl.ylabel(unit_lab_y);}
  variable spec_map_name = "spec_map.png"; while (stat_file(spec_map_name) != NULL) spec_map_name="X"+spec_map_name;
  
  %%%%%%%%%%%%%%%%%% changing spec_map accoring to the required color scale %%%%%%%%%%%%%%%%%%%%
  % so far there should not have been changes to the spec_map
  %
  variable min_spix      = qualifier("min_spix", min(spec_map[where(avg_lum>0)]));
  variable max_spix      = qualifier("max_spix", max(spec_map[where(avg_lum>0)]));
  %% setting user specified color scheme, if required
  if (qualifier_exists("color_scheme"))
  {
    variable h, s, l; 
    (h,s,l) = rgb2hsl(png_gray_to_rgb(spec_map, color_scheme; gmin= min_spix, gmax=max_spix)); % color scheme just in valid spix range
    if(nsigma_lo != 0) l[where(mlo < med_lo + sigma_lo * nsigma_lo)] = bkgr;
    if(nsigma_hi != 0) l[where(mhi < med_hi + sigma_hi * nsigma_hi)] = bkgr;
    
    if (bluebkgr ==1){
        if(nsigma_lo != 0) h[where(mlo < med_lo + sigma_lo * nsigma_lo)] = 0.66; 
	if(nsigma_lo != 0) s[where(mlo < med_lo + sigma_lo * nsigma_lo)] = 1; 
	if(nsigma_lo != 0) l[where(mlo < med_lo + sigma_lo * nsigma_lo)] = 0.2; 
    
	if(nsigma_hi != 0) h[where(mhi < med_hi + sigma_hi * nsigma_hi)] = 0.66;
	if(nsigma_hi != 0) s[where(mhi < med_hi + sigma_hi * nsigma_hi)] = 1; 
	if(nsigma_hi != 0) l[where(mhi < med_hi + sigma_hi * nsigma_hi)] = 0.2; 
    }
    
    png_write_flipped(spec_map_name, hsl2rgb(h, s, l));
  } 
  %% otherwise use the default color schemes, setting the spectral index to colors between 0 (red) and 2/3 (blue)
  else
  {
    if(max(values.avg_lum)==0) {
      message("NO EMISSION???");
      spec_map[*,*]=0;
      avg_lum[*,*]=0;
    }
    else{
      if(max_spix<min_spix) message("MIN_SPIX SHOULD NOT BE LARGER THAN MAX_SPIX");
      spec_map = _min(_max(spec_map,min_spix), max_spix);
      if(min_spix*max_spix>=0){          %if min and max spix are the same sign, limit color scale to their range
	spec_map -= min_spix;
	spec_map /= (max_spix-min_spix)*3./2;
      }
      else{ % setting green to be at spix=0
	spec_map[where(spec_map>0)] /= max_spix*3;
	spec_map[where(spec_map<0)] /= -min_spix*3;
	spec_map += 1./3;
      }
      
      if(inv_color==1) spec_map = 2./3. - spec_map;  %inverting colors so red is a larger spectral index
    }
    %% where the spectral index is outside of the range, make luminosity 0
    %avg_lum[where(spec_map<min_spix-1e-5)]=0;
    %avg_lum[where(spec_map>max_spix+1e-5)]=0;
    png_write_flipped(spec_map_name, array_map(Integer_Type, &hsl2rgb, spec_map, 1, avg_lum));
  }
  pl.plot_png(spec_map_name);

  %% making color scale bar
  ifnot (qualifier_exists("no_scalebar")){
    variable scale_name = "scale.png"; while (stat_file(scale_name) != NULL) scale_name="X"+scale_name;
    
    variable cs = xfig_plot_new (width/25., height);
    cs.world (0, 1, min_spix, max_spix);
    cs.xaxis (;off);
    cs.y1axis (;off);
    cs.y2axis (;on,color= color);
    ifnot (qualifier_exists("no_labels")) {
      cs.y2label ("Spectral Index");}
    
    if (qualifier_exists("h_scalebar")){
      cs = xfig_plot_new (width, height/25.);
      cs.world (min_spix, max_spix,0, 1);
      cs.yaxis (;off);
      cs.x1axis (;off);
      cs.x2axis (;on,color= color);
      ifnot (qualifier_exists("no_labels")) {
	cs.x2label ("Spectral Index");
      }
    }

    variable N = 256;
    variable scale;
    variable cs_shape = (qualifier_exists("h_scalebar") ? [1,N] : [N,1]);
    
    if (qualifier_exists("color_scheme")) {
      scale = [min_spix: max_spix: #N];
      png_write_flipped(scale_name, png_gray_to_rgb(_reshape(scale,cs_shape),color_scheme));
    } 
    else {
      if(min_spix*max_spix>=0){          %if min and max spix are the same sign, limit color scale to their range
	scale = [0:2./3.:#N];
      }
      else {
	variable N_neg = nint( abs(min_spix/(max_spix-min_spix)) *N);
	scale = [[0:1:#N_neg],[1:2.:#(N+1-N_neg)][[1:]]] / 3.0;
      }
      if(inv_color==1) scale = 2./3 - scale;       %inverting scale
      png_write_flipped(scale_name, hsl2rgb( _reshape(scale,cs_shape), 1, 0.5));
    }
    cs.plot_png(scale_name);
  }
  
  %% adding source and date
  if (src_name != NULL){
    pl.xylabel(0.05,0.95,src_name,-0.5,0.5; world0, depth = 30, color=color);
  }
  if (obs_date != NULL){
    pl.xylabel(0.95,0.95,obs_date, 0.5,0.5; world0, depth = 30, color=color);
  }

  %% making beam
  variable beam_maj = @values.major;%fits_read_key (name8, "BMAJ")*(3.6e+6)/2.0;   % clean beam major axis in mas (semi major!)
  variable beam_min = @values.minor;%fits_read_key (name8, "BMIN")*(3.6e+6)/2.0;   % clean beam minor axis ins mas (semi minor!)
  variable beam_ang = @values.posang*PI/180.;%fits_read_key (name8, "BPA")/180*PI; % clean beam postion angle
  variable beam     = xfig_new_ellipse(beam_min,beam_maj);  % major axis to north, pos_angle = 0
  variable beam_clr = qualifier("beam_color",  (print_mode ? "gray" : "grey") );
  % apply custom units set with xy_unit
  beam_maj *= unit_fac;
  beam_min *= unit_fac;
  
  beam.set_pen_color(beam_clr);
  beam.rotate(vector(0,0,1),beam_ang);
  beam.scale( beam_ra_scale, beam_dec_scale , 0);
  beam.translate(vector(0.5-beam_maj*width/(ra_max-ra_min),0.5+beam_maj*height/(dec_max-dec_min),0));
  beam.area_fill=20;
  beam.fill_color=xfig_lookup_color(beam_clr);
  pl.add_object(beam);
  
  %% outputting file and cleaning up
  if (qualifier_exists("no_scalebar"))
    pl.render (outname);
  if (qualifier_exists("h_scalebar")) {xfig_new_vbox_compound (cs, pl, 0.4).render (outname);
      ()=remove(scale_name);}
  else {
    xfig_new_hbox_compound (pl, cs, 0.4).render (outname);
    ()=remove(scale_name);
  }
  ()=remove(spec_map_name);
}

